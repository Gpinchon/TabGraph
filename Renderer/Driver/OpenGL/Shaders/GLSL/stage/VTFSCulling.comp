#include <Lights.glsl>
#include <VTFS.glsl>

layout(local_size_x = VTFS_LOCAL_SIZE, local_size_y = 1, local_size_z = 1) in;

layout(binding = 0) uniform CameraBlock
{
    // TransformUBO transform;
    mat4 projection;
    mat4 view;
}
u_Camera;

layout(std430, binding = 0) readonly buffer VTFSLightBaseBufferSSBO
{
    uint lightCount;
    uint _lightBasePadding[3];
    LightBase lightBase[VTFS_BUFFER_MAX];
};

layout(std430, binding = 0) readonly buffer VTFSLightSpotBufferSSBO
{
    uint _lightSpotPadding[4];
    LightSpot lightSpot[VTFS_BUFFER_MAX];
};

layout(std430, binding = 1) restrict buffer VTFSClustersSSBO
{
    VTFSCluster clusters[];
};

void main()
{
    mat4x4 MVP                   = u_Camera.projection * u_Camera.view;
    const uint clusterIndex      = gl_WorkGroupSize.x * gl_WorkGroupID.x + gl_LocalInvocationID.x;
    clusters[clusterIndex].count = 0;
    for (uint lightIndex = 0; lightIndex < lightCount; ++lightIndex) {
        uint lightType     = lightBase[lightIndex].commonData.type;
        vec3 lightPosition = lightBase[lightIndex].commonData.position;
        float lightRadius  = lightBase[lightIndex].commonData.range;
        if (lightType == LIGHT_TYPE_SPOT) {
            lightRadius /= 2.f;
            lightPosition += lightSpot[lightIndex].direction * lightRadius;
        }
        ProjectSphereToNDC(lightPosition, lightRadius, MVP);
        if (SphereIntersectsAABB(
                lightPosition, lightRadius,
                clusters[clusterIndex].aabb.minPoint,
                clusters[clusterIndex].aabb.maxPoint)) {
            clusters[clusterIndex].index[clusters[clusterIndex].count] = lightIndex;
            clusters[clusterIndex].count++;
            if (clusters[clusterIndex].count == VTFS_CLUSTER_MAX)
                break;
        }
    }
}
